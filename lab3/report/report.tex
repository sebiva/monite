% Sebastian Ivarsson %

\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{url}
%%\usepackage{showframe}
%\usepackage[parfill]{parskip} %% New line instead of indentation for paragraphs

\usepackage{geometry}
\geometry{  a4paper,
            total={210mm,297mm},
            left=25mm,
            right=25mm,
            top=25mm,
            bottom=35mm,
        }

\hypersetup{    pdftitle={AFP Assignment 3},%
                pdfauthor={Sebastian Ivarsson, John Martinsson},%
                pdfborder={0 0 0},%
            }

\usepackage{listings}
\usepackage{amsmath}
\usepackage[parfill]{parskip}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{amssymb}
\usepackage{dsfont}

% Table
\usepackage{tabularx}
\usepackage{tikz}
%\tikzset{every picture/.style={remember picture}}

\renewcommand\tabularxcolumn[1]{m{#1}}
\newcolumntype{M}{>{\centering\arraybackslash}m{1cm}}

\newcommand\tikzmark[2]{%
    \tikz[remember picture,baseline]
    \node[inner sep=2pt,outersep=0] (#1){#2};%
    }

\newcommand\link[2]{%
    \begin{tikzpicture}[remember picture, overlay, >=stealth, shift={(0,0)}]
        \draw[->] (#1) to (#2);
    \end{tikzpicture}%
    }

% Strikeout
\usepackage[normalem]{ulem}

\usepackage{algpseudocode} % Pseudocode
\usepackage{amsthm} % Theorems

\newtheorem{myclaim}{Claim}[section]
\newtheorem{mytheorem}{Theorem}[section]
\newtheorem{mydef}{Definition}

\begin{document}



% Settings %
\pagestyle{fancy}
\fancyhead[L]{Advanced Functional Programming\\TDA342\\20150301}
\fancyhead[R]{Sebastian Ivarsson\\John Martinsson\\Fire: group 13}

\renewcommand{\headrulewidth}{0pt} \setlength{\headsep}{30pt}
\setlength{\headheight}{30pt}
%% %\addtolength{\voffset}{-50pt}
%% %\addtolength{\textheight}{50pt}
%% \setlength{\marginparsep}{0pt}
%% \setlength{\marginparwidth}{0pt}
%% \addtolength{\textwidth}{90pt}
%% \addtolength{\hoffset}{-50pt}
% \Settings %

\title{Assignment 3}
\author{Sebastian Ivarsson, John Martinsson}
\maketitle
\thispagestyle{fancy}

%\begin{center}

%\input{logo.tex}
%\end{center}


\section{Assignment 3, Part II}
In this part of the assignment we have worked with the library haskeline, chosen
in Part I, which we have used in an implementation of a shell. We have also
studied the library, added some documentation, and come up with an idea of how
it would be possible to improve the completion module in the project.

\subsection{Task 1 - Writing code}

\textbf{Modification / extension}: \textit{Show how the library could be changed to improve it in
some aspect, or extend the library with some useful feature. Implementing the
suggested feature is of course the best thing, but since this is a short project
we understand if the result is limited to a partial solution or even a sketch of
the implementation along with a description (in your report) of what
difficulties you faced when trying to implement it.}

We have focused on the tab-completion (see Completion.hs) part of haskeline in
this project, as it is what we sought out to use in our shell implementation. We
have extended the previous interface in the module
System.Console.Haskeline.Completion with a new function called listPathFiles,
which instead of only looking in the directory which the application is executed
from, looks in a set of supplied directories. In our case, this is used to
tab-complete binary commands when written in the shell. We also realized that
the interface could be further improved by a small compositional language in
which the application user could build complex completion functions from simple
completion functions, and in such a way allow easy composition of said
functions. For a suggestion of such an interface (sadly undefined) see the end
of the file System/Console/Haskeline/Completion.hs.

\textbf{Advanced usage / tutorial}: \textit{Show some examples of what the library can be used
for. The examples must demonstrate a deep understanding of the library (or part
of it). Note: This task is potentially much simpler than the other two. Making a
good tutorial is enough for a passing grade on this assignment, but is unlikely
to yield a higher grade.}

The example of how the library can be used is the implementation of our shell
Monite. We chose to try and create an interesting application to show the usage
of haskeline, and in order to get a fairly functional shell working, quite some
work was required. We thought it would be more interesting to see an actual
working application and put in this work in order to get it working properly.

See section \ref{monite} for more information about how the shell works.

\subsection{Task 2 - Documentation}
Haskeline is a user interface used to handle line input for command-line
programs. It is primarily used to enable a rich editing interface when entering
input on the command line, for example, functionality such as Emacs- and
Vim-Mode is present by default, which allows the end-user to edit commands on
the command-line with their favorite key-bindings.

It also suits our needs very well, as the application programmer can define
their own 'completion functions', which are basically functions used to
intelligently suggest completions for a command that is being entered on the
command-line.

\subsubsection{Description of library interface}
Since we have focused on the completion part of the haskeline project we have
thoroughly read through both System/Console/Haskeline/Completino.hs, and
System/Console/Haskeline/Command/Completion.hs, and we have added comments for
the uncommented functions in the latter (see diff-haskeline). Apart from
this, we have also looked through the rest of the code to get an overview of
the structure of the library.

Haskeline provides an easy to use interface. The documentation for this
interface is good, and we will therefore give a brief summary on how to use it,
and what functionality is available to the application programmer.

\subsubsection{Settings}
The application programmer has a couple of settings available. It is possible to
configure how history should be handled, i.e., which history file to use, and if
history should be automatically added to the history file. History in this
context is all non-empty lines that has been entered into the command-line of
the application. This enables the end-user of the application to search through
previously entered commands, or simply browse through them.

Another quite useful setting is the ability to set custom 'completion
functions', which allows the application programmer to decide in what manner the
tab completions should be handled. The interface for using these were in our
case a little cumbersome, and we have made some suggestions on how to improve
upon this with a compositional interface for completion functions.

\subsubsection{Preferences}
Haskeline also provides the application programmer with the ability to read
end-user preferences from a file, which by default is read from the file
$\mathtt{\sim}$\textit{/.haskeline}. This allows the end-user to configure the
application to his/her liking. For example:

\begin{verbatim}
  editMode: Vi
  completionType: MenuCompletion
  maxhistorysize: Just 40
\end{verbatim}

Which changes how the interface behaves for the end-user.

\subsubsection{Interesting techniques}
Haskeline uses the Haskell Foreign Function Interface (FFI) when interfacing
with C in order to be able to perform very low level operations on the system.
For example the System.Console.Haskeline.Directory module make use of FFI in
order to define some basic system file handling functionality which was not
available in older versions of GHC.

Another interesting technique used is the monad stack in InputT, where
haskeline make use of Readers with IORefs (which is basically a State) in order
to prevent state loss when encountering exceptions such as Ctrl-c.

\begin{verbatim}
-- | A monad transformer which carries all of the state and settings
-- relevant to a line-reading application.
newtype InputT m a = InputT {unInputT ::
            ReaderT RunTerm
            -- Use ReaderT (IO _) vs StateT so that exceptions (e.g., ctrl-c)
            -- don't cause us to lose the existing state.
            (ReaderT (IORef History)
            (ReaderT (IORef KillRing)
            (ReaderT Prefs
            (ReaderT (Settings m) m)))) a}
        deriving (Monad, MonadIO, MonadException)
\end{verbatim}

By having a stack of readers, some of which use IORefs (to simulate a state),
the monad might be more convenient to work with as getting any of the
``variables'' requires only running ask. This is because of the clever way
typeclasses are used within the library (System/Console/Haskeline/Monads.hs).
Since monad transformers can ``forward'' their reader capabilities through the
stack by using lift, the ask function can be used at any level to get any of
the IORefs in the stack, resulting in a simulated state which is both easy to
use and resistant to errors.

%they have made it possible to
%use the ask function everywhere in monads of Reader instance.

%The magic comes from defining clever instances for the monad transformers in
%haskeline Monads.hs, which allows ask to get any immutable variable in the
%reader stack.

An alternative stack as we see it would be

\begin{verbatim}
newtype InputT m a = InputT {unInputT ::
            ExceptT Err
            (StateT Env
            (ReaderT RunTerm
            (ReaderT Prefs
            (ReaderT (Settings m) m)))) a }

data Env :: Env {
  history  :: History
  killring :: KillRing
}
\end{verbatim}

Where it would also be possible to preserve the state when encountering an
exception. However, according to this
\footnote{\url{http://stackoverflow.com/questions/17645655/exception-handling-with-statet-vs-readert-ioref}}
post, there is still an issue with using this technique. Even though the base
rule of always keeping the exceptions ``on top'' of the state in order to
preserve the state when something goes wrong, it does not apply to the mtl
transformer stack, as the state that is returned is not the latest in the
computation. The reason for this, as explained in the post, is that IO in
itself contains a sort of Error handling, and by putting IO inside StateT, we
are effectively putting a StateT on top of an Error Monad, which will not work.
By using IORefs, the state is placed inside the IO monad, which means the state
can be preserved properly.

In our own transformer stack, we do not use this technique however, as we are
not that interested in keeping the state of an expression that has gone wrong,
and therefore use the basic StateT inside of an ExceptT.

The below example illustrates how the type signatures of an ExceptT
outside/inside of a StateT allows for preservation of state when encountering
an exception.

\begin{verbatim}
  runExceptT :: ExceptT e m a -> m (Either e a)
  runStateT  :: StateT s m a -> s -> m (a, s)

  type X = ExceptT e (StateT s m) r
  x :: X

  (runExceptT x) :: StateT s m (Either e r)
  (runStateT (runExceptT x)) :: s -> m (Either e r, s)

  -- Here we both the error and the state
  runM :: X -> s -> m (Either e r, s)
  runM x = runStateT (runExceptT x)

  type Y = StateT s (ExceptT e m r)
  y :: Y

  runStateT y :: s -> ExceptT e m (r, s)
  runExceptT (runStateT y s) :: m (Either e (a, s))

  -- Here, we can't have both an error and a state
  runM' :: Y -> s -> m (Either e (a, s))
  runM' y s = runExceptT (runStateT y s)
\end{verbatim}

\subsection{The Monite shell}
\label{monite}

Monite is a shell written in Haskell. During the Feldspar guest lecture we
learned that many hackage packages are named after various types of rock
formations. Following this convention the name Monite (an abbreviation) was
derived from the group name Ammonites used for extinct marine animals, e.g.,
fossils of various types of shells, which is what we are developing, a shell.

\subsubsection{Alternative Haskell Shells}

During the start of the project we looked into some existing shells written in
haskell, none of which really did what we sought out to do, and thus, we set out
to write our own shell from scratch in the hope to both learn more, and get the
functionality we wanted. The shells we looked at were: Turtle, Hell, Shelly.

\textbf{Turtle}

Turtle is a scripting language that also works as a shell. The shell runs
within ghci though, and has predefined functions for ls, rm and so on instead
of using the system binaries. It is more focused on writing scripts, and was
not quite what we were looking for.

\textbf{Hell}

Hell is more focused on being a real shell, using shell-conduit to execute
system binaries and ghc to evaluate haskell expressions that are written at the
prompt. Like our shell, it uses haskeline for its tab completion and history.
This shell however, unlike regular shells like bash, is typed, and requires
writing quotes for string literals, for example ls ``-l''.

\textbf{Shelly}

Is also more focused as a scripting language more than an interactive shell,
and was thus not suitable for our needs.

None of these packages were quite what we were looking for. We wanted
our own shell to be more bash-like, with some extra features such as list
comprehensions. We also wanted it to handle the low-level things by itself,
using the exec - like createProcess function from System.Process rather than
the more general runCommand, which handles piping and such by itself. This
choice means it should be possible to replace the calls to createProcess and
createPipe with calls to the standard unix programs exec and pipe using FFI.


\subsubsection{Used libraries}

The Monite shell is built using a couple of libraries; the major three being:
haskeline, BNFC, and process.

Haskeline is used used to provide a rich command-line interface for the
end-user. Monite is customizable to the end-users preferences in the
configuration file $\mathtt{\sim}$\textit{/.moniterc}. It also provides Monite
with a history file, and useful completion functions. The end-user can
tab-complete commands entered at the command-line, and using our customized
completion function we look in the users \$PATH, in order to suggest completions
for the first word entered at the command-line, and then we use the standard
file completion from haskeline for tab-completion of the arguments.

BNFC is a parsing library, and is used in Monite to parse a small scripting
language, which is available to the end-user to enter at the command line. We
have written our own BNFC grammars, from which BNFC can then generate a lexer,
and a parser, which are used to parse the commands entered on the command-line
in Monite. The abstract syntax tree is then evaluated using our own own
interpreter.

The process library is used to allow for execution, and handling of binary
processes such as ls, cat, echo, etc, as well as to create pipes to allow
piping of commands, and redirection of stdout. We support redirection, e.g.,
"ls > filef", and "cat < filef" and piping, e.g., "ls | wc | wc | wc".

\subsubsection{Analysis of our code}
In the main loop of our program we prompt the end-user for commands using the
haskeline interface, and we then send these commands to our interpreter.

In the interpreter we first parse the input into a program (abstract syntax
tree), and then send the program to the evaluator.

The evaluator evaluates the program recursively, and handles exceptions that are
thrown (in case some command is invalid etc), which results in useful error
messages for the end-user.

The grammars are specified in the file Grammar.cf, which with the help of bnfc
generates a parser, Par.hs (along with a lexer and an abstract syntax tree).

We use the createProcess function from the process library to execute binary
commands, along with their arguments, which are taken as is form the input. In
order to enable piping and redirection, we keep handles in our state, which are
sent to createProcess when evaluating CPipe, COut, and CIn commands.

Since everything in the shell is considered a string until proved otherwise, we
sometimes have to re-interpret a command. This is what we use wrappers for.  For
example when a variable contains a complex command such as "echo hello > filef",
we have to interpret the string contained in the variable when it is used within
(()).

\subsubsection{Usage - How Monite works}
\label{features}
The syntax of our scripting language is as follows:

\begin{verbatim}
  LetExp ::= let Lit = Wrap | let Lit = Wrap in LetExp | Exp
  Exp    ::= { LetExp : Lit <- Exp } | [ Cmd, Cmd ... ] | Wrap Wrap ...
  Wrap   ::= (( Wrap Wrap ... )) | Cmd
  Cmd    ::= Text Text ... | Cmd ``|'' Cmd | Cmd > Lit | Cmd > Lit
  Text   ::= String | Lit
\end{verbatim}

Where a literal is a sequence of characters not in the set:
\begin{verbatim}
  "\"\',()[]<>|{};:\t\n "
\end{verbatim}

\textbf{Let expressions}

Let expressions extend the current scope with a new variable with a name of
type Lit. If a variable is called ``x'', it can be referenced by using ``\$x''.
When using the let x = $\dots$ syntax, the variable is set globally, but when
the let x = $\dots$ in Exp syntax is used, the variable is only available
within Exp, and deleted afterwards. Example:

\begin{verbatim}
  let x = 42 ;
  let x = hello in echo $x ; # Should print "hello"
  echo $x ; # Should print "42"
\end{verbatim}

Only values can be assigned to variables. This is enforced by using the type
Wrap, which is either a command (which can be stored as string) or list of
Wraps within parentheses. These parentheses mean that whats inside it should be
evaluated before it is stored. Therefore, let x = ls will just store the string
``ls'', whereas let x = ((ls)) will store the output of running ls (As of now,
we don't handle the formatting of the command more than joining the string with
spaces, this could be improved in a more polished version). Example:

\begin{verbatim}
  let x = ls ;
  $x ; # Will execute ls
  let x = ((ls)) ;
  echo $x ; # Will print the output of ls using echo
\end{verbatim}

\textbf{List comprehensions}

The list comprehension evaluates the rightmost expression to a list of strings,
and for each string in this list, assigns it to the variable $i$ and
evaluates the leftmost expression with $i$ in its context.

\begin{verbatim}
  { echo $i : i <- ls } ; # echo each element from the list from ls
\end{verbatim}

\textbf{Lists}

Lists contain commands, and evaluating a list by itself only prints the
commands as they are. They can be used within list comprehensions to execute
the commands, for example:

\begin{verbatim}
  { $i : i <- [pwd, ls] } ; # Should print the output of first pwd, the ls
\end{verbatim}

\textbf{Commands and Wraps}

Commands are the things that are actually executed in the language. A command
is a list of Text (Strings or Literals, which may contain variables), perhaps
combined with pipes and redirects. Since texts can contain variables,
evaluating a command involves replacing all variables by their value and
redirecting the input/output according to pipes.

In order to make the language more useful, Wraps were introduced to let the user
capture the output of a command and use it as a value. As explained earlier,
anything within ``(())'' should be evaluated before it is used. Since it can
contain variables that must be replaced by their values, and these values may
contain pipes and redirects (see example below), it must be flattened to a
string and then reinterpreted. This way, the output of a command can be used
just like a value. To make it behave like a single value, explicit " are added
around the result when it is not the first part of a command, as it should be
the binary to be executed then.

\begin{verbatim}
  let x = ls -l | wc in echo $x (($x)) ; # Should print both
\end{verbatim}




The syntax works as follows: Everything that is entered is interpreted as
strings, unless it is wrapped in ``$\left( \left(  \right) \right)$'' (in which
case it is taken as an expression returning a string).

\begin{verbatim}
  let x = ls -l | wc in echo $x (($x))
\end{verbatim}

This will print first the text ``ls -l | wc'' and then the result of running
that command. (The formatting is not yet fully correct, but could be fixed with
some more time)

\subsubsection{Development}

We knew going in that the undertaking of writing an entire, and useful shell
during this project would not be feasible. However, we managed to get a working
shell (albeit limited) up and running, and we are pleased with the results.

\textbf{Techniques and Reflection}

During the development of Monite, we have used several of the development
techniques discussed in the course. Obviously, monads have played a huge role
when writing our program, as we are in need of both State, IO and Error
handling. The MoniteM monad is constructed using concept of monad transformers
which has been an important part of the course. Using transformers we get a lot
of functionality for free, for example getting and modifying the state,
performing io actions using liftIO and throwing and catching errors. One thing
that was tricky despite our transformer stack was to use it along with the
InputT transformer from haskeline. In order to catch the Ctrl-C interrupt, our
monad would have had to be an instance of the MonadException typeclass defined
within haskeline. Even though there were instances for some transformers, there
was none for the ExceptT that we use, only for the deprecated ErrorT. Luckily,
it was enough to run IO-actions within the things we wanted to catch, and IO was
one of predefined instances. Otherwise we would either have had to create our
own instance of MonadException which proved to be tricky, change our transformer
stack to the deprecated ErrorT which would have been a step back, or possibly
update the monad stack in haskeline with ExceptT instead of ErrorT, which would
be quite a large undertaking.

Throughout the project, we noticed that it is hard to nail the grammars for a
scripting language in the first try. It took some iterations getting the
grammars right, and there is still room for improvement, perhaps using something
else than bnfc. Reworking the grammar took quite some time as the entire
interpreter must be changed to reflect it, and it can thus be worth taking even
more time getting it right in the first place.

\textbf{Missing features}

This is by no means an exhaustive list of missing features, however, it is a
list of some of the features we would have liked to implement with enough time.

1. More general configuration file, the configuration supported now is that
which haskeline provides by default, it would be nice to be able to set a custom
prompt, and define custom functions. This could be done in many ways, and one
interesting way would be to expose a haskell config file to the end-user, in
which he/she could define their own functions (with the whole power of haskell
at their disposal), and then allow the end-user to run a command such as "monite
--recompile" which would recompile the whole shell with the user defined
functionality. This is used in applications such as xmonad, and provides the
end-user with a very rich, and powerful configuration interface. An example of a
library that claims to do this is 'dyre', which might be interesting to look
into.

Another way would be to extend the scripting language with support for
functions, which we realized was beyond the scope of this project. It would be
nice to be able to set environment variables in the scripting language, e.g.,
allow the end-user can set his/her own \$PATH.

2. Job control is another missing feature that Monite could be extended with
(probably a necessity for it to be considered a usable shell).

3. There is also room for improvements on the completion functions used by
Monite.  It would be possible to write completion functions for arguments to
binary commands which looks through the documentation of the command, and prints
suggestions for what arguments could be given to the command. For example:

\begin{verbatim}
  $> git <Tab>
\end{verbatim}

could go through the git documentation and suggest all possible arguments that
could be entered.

\textbf{Known Issues}

After testing the shell throughout the development using ghci, we managed to
get the Ctrl-C - handling working as intended, where pressing Ctrl-C during
execution of an expression would result in a message being printed and the
whole expression aborted. Upon testing the compiled version prior to submission
though, we discovered that it does not behave this way when compiled. Instead,
only the current command is aborted, for example sleep 5 ; ls will print the
output of ls even if Ctrl-C is pressed during the execution of sleep. As this
issue was not discovered until just before the hand in, there was no time to
look into a fix.

Using wraps does not currently conserve the formatting of the run command (see
the last example of let expressions in section \ref{features} for an example of
this behavior). It seems this is because of how we treat the commands, and that
the words function treats tabs as spaces. Fixing this would require us to store
the commands differently, and since this is a cosmetic issue, we have not spent
time trying to fix it as of now.

\subsection{Outcome}

Overall, we are pleased with the result of this project. We have managed to
create a (perhaps a bit limited) functioning shell, that can perform most basic
tasks, and have learned a lot in the process. We have also had the opportunity
to look at and change a part of the haskeline code base. We have stuck quite
closely to our original plan, even though the grammar and some concrete syntax
had to be changed (for example using ``$\{\}$'' and ``$:$'' in list comprehensions
to avoid confusion between ordinary lists and pipes for bnfc).

We realized quickly that having functions in our language would be way beyond
the scope of this project, but also that getting the few features we wanted
proved to be harder than we had initially thought.

As was predicted, there was not much time left for testing. We had a small
testsuite running throughout, but had some problems with making it fully
automatic, as the redirection of its output seemed to give the strings in
different order. Also, making the tests fully general is hard, as the results
of the commands run depends on the system environment. One idea however, is
to have the testsuite run another shell (for instance bash) and perhaps
generate random commands that are run by both shells, and then compare the
output. The challenge would be to generate commands that behave nicely and don't
reformat your hard drive.








\newpage
\appendix

\section{Part I - (Same as last submission)}
For this assignment, we have chosen the package ‘haskeline’. Haskeline is used
to provide a more advanced means of getting input from the user than using the
standard ‘getLine’ function in Haskell. It provides functionality similar to
that of the GNU 'readline' library for C, used in many linux applications. We
think haskeline is an interesting package as it provides a very easy way of
getting a nice input interface for your haskell command line applications.

Our idea is to implement a simple shell in haskell using this library along with
the process library to pass on the calls to the system binaries. In order to
make it a bit more interesting, we thought it would be fun to add some basic
scripting functionality to the shell (as in bash/zsh). Since the project is so
short, this scripting language would have to be very limited. The things we have
planned are:

Variables using let expressions, for example:
\begin{verbatim}
  let $x = ls -la in x | wc; cd ..; x
\end{verbatim}

Which would be equivalent to:

\begin{verbatim}
  ls -la | wc; cd ..; ls -la
\end{verbatim}

Not only should it be possible to have variables in scope for the coming
command, but also for the whole session:

\begin{verbatim}
  let $x = hello; echo $x
\end{verbatim}

List comprehensions over lists of output values from another command:

\begin{verbatim}
  [ echo $x | $x <- ls ]
\end{verbatim}

Which would correspond to (in zsh):

\begin{verbatim}
  for $f in $(ls); do echo $f; done
\end{verbatim}

Functions (this is by far the hardest part, and may not be feasible for such a
small project):

\begin{verbatim}
  let f n = n + 1 in echo (f 0)
\end{verbatim}

Which would be interpreted / evaluated as:

\begin{verbatim}
  echo 1
\end{verbatim}

In order to write such a shell application, we would need to write a parser for
the user input. Luckily, the package 'bnfc' makes it easy to generate a parser
automatically from a specified grammar, and by having a very restricted set of
features it should not be too hard to write those rules.

With a finished parser, the challenge will be to put it all together, i.e.,
handling user input via haskeline, parsing (and interpreting) the scripting
language via the bnfc generated parser, and handling system binary execution via
the process library. Our haskell shell will also need to handle the state of the
shell, that is, the current path and variables. One possible extension would be
to implement even more advanced shell functionality such as job control (way out
of scope for this project, but it would be cool to have).


We believe this project would cover the course goals in the following ways:

\textbf{DSLs}: Both bnfc and haskeline are DSLs, so working with them will require
understanding how they work. Our own scripting language will be a DSL in itself,
and by implementing it, we will need to handle both the concrete and abstract
syntax of our language, as well as the semantics when evaluating it.

\textbf{Types}: Writing the code for this project will inevitably include writing our own
types, and since our shell will no doubt have to be at least in the IO monad
(and the State monad), we will use monad transformers to construct it. Also, the
abstract syntax will be an algebraic datatype.  The haskeline library uses quite
a big stack of monad transformers (mostly ReaderT). If functions are to be
implemented in our shell language, we might need to use a GADT to model the
expressions.

\textbf{Spec / Testing}: Ideally, we would also like to create  a proper testsuite
(preferably using quickCheck) for our program, but as time will be very limited,
this will only be done if there is time left. Since the program will be mostly
monadic, proving properties might be hard.

We realise that this might be an ambitious undertaking, and we have consulted
one of the TAs about the project. The recommendation was to focus on the
haskeline library, and instead question it’s implementation choices, and try to
make suggestions on how to improve upon them. However, we feel that writing a
simple shell could be a really interesting project, and we would like to give it
a try, but, should we realise early that this is not feasible within the limited
time-frame of this course, we will instead go with the TAs recommendation and
focus on the haskeline library itself.



\end{document}
