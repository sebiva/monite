% Sebastian Ivarsson %

\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{url}
%%\usepackage{showframe}
%\usepackage[parfill]{parskip} %% New line instead of indentation for paragraphs

\usepackage{geometry}
\geometry{  a4paper,
            total={210mm,297mm},
            left=25mm,
            right=25mm,
            top=25mm,
            bottom=35mm,
        }

\hypersetup{    pdftitle={AFP Assignment 3},%
                pdfauthor={Sebastian Ivarsson, John Martinsson},%
                pdfborder={0 0 0},%
            }

\usepackage{listings}
\usepackage{amsmath}
\usepackage[parfill]{parskip}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{amssymb}
\usepackage{dsfont}

% Table
\usepackage{tabularx}
\usepackage{tikz}
%\tikzset{every picture/.style={remember picture}}

\renewcommand\tabularxcolumn[1]{m{#1}}
\newcolumntype{M}{>{\centering\arraybackslash}m{1cm}}

\newcommand\tikzmark[2]{%
    \tikz[remember picture,baseline]
    \node[inner sep=2pt,outersep=0] (#1){#2};%
    }

\newcommand\link[2]{%
    \begin{tikzpicture}[remember picture, overlay, >=stealth, shift={(0,0)}]
        \draw[->] (#1) to (#2);
    \end{tikzpicture}%
    }

% Strikeout
\usepackage[normalem]{ulem}

\usepackage{algpseudocode} % Pseudocode
\usepackage{amsthm} % Theorems

\newtheorem{myclaim}{Claim}[section]
\newtheorem{mytheorem}{Theorem}[section]
\newtheorem{mydef}{Definition}

\begin{document}



% Settings %
\pagestyle{fancy}
\fancyhead[L]{Advanced Functional Programming\\TDA342\\20150301}
\fancyhead[R]{Sebastian Ivarsson\\John Martinsson\\Fire: group 13}

\renewcommand{\headrulewidth}{0pt} \setlength{\headsep}{30pt}
\setlength{\headheight}{30pt}
%% %\addtolength{\voffset}{-50pt}
%% %\addtolength{\textheight}{50pt}
%% \setlength{\marginparsep}{0pt}
%% \setlength{\marginparwidth}{0pt}
%% \addtolength{\textwidth}{90pt}
%% \addtolength{\hoffset}{-50pt}
% \Settings %

\title{Assignment 3}
\author{Sebastian Ivarsson, John Martinsson}
\maketitle
\thispagestyle{fancy}

%\begin{center}

%\input{logo.tex}
%\end{center}


\section{Assignment 3, Part II}
In this part of the assignment we have worked with the library haskeline, chosen
in Part I, which we have used in an implementation of a shell. We have also
studied the library, and tried to come up with possible improvements on its
implementation.

\subsection{Task 1 - Writing code}

\textbf{Modification / extension}: \textit{Show how the library could be changed to improve it in
some aspect, or extend the library with some useful feature. Implementing the
suggested feature is of course the best thing, but since this is a short project
we understand if the result is limited to a partial solution or even a sketch of
the implementation along with a description (in your report) of what
difficulties you faced when trying to implement it.}

We have focused on the tab-completion (see Completion.hs) part of haskeline in
this project, as it is what we sought out to use in our shell implementation. We
have extended the previous interface in the module
System.Console.Haskeline.Completion with a new function called listPathFiles,
which instead of only looking in the directory which the application is executed
from, looks in a set of supplied directories. In our case, this is used to
tab-complete binary commands when written in the shell. We also realized that
the interface could be further improved by a small compositional language in
which the application user could build complex completion functions from simple
completion functions, and in such a way allow easy composition of said
functions. For a suggestion of such an interface (sadly undefined) see the end
of the file System/Console/Haskeline/Completion.hs.

\textbf{Advanced usage / tutorial}: \textit{Show some examples of what the library can be used
for. The examples must demonstrate a deep understanding of the library (or part
of it). Note: This task is potentially much simpler than the other two. Making a
good tutorial is enough for a passing grade on this assignment, but is unlikely
to yield a higher grade.}

The example of how the library can be used is the implementaiton of our shell
monite. We chose to try and create an interesting application to show the usage
of haskeline, and in order to get a fairly functional shell working, quite some
work was required. We thought it would be more interesting to see an actual
working application and put in this work in order to get it working properly.

See section \ref{monite} for more information about how the shell works.

\subsection{Task 2 - Documentation}
Haskeline is a user interface used to handle line input for command-line
programs. It is primarily used to enable a rich editing interface when entering
input on the command line, for example, functionality such as Emacs- and
Vim-Mode is present by default, which allows the end-user to edit commands on
the command-line with their favorite key-bindings.

It also suits our needs very well, as the application programmer can define
their own 'completion functions', which are basically functions used to
intelligently suggest completions for a command that is being entered on the
command-line.

\subsubsection{Description of library interface}
Haskeline provides an easy to use interface. The documentation for this
interface is good, and we will therefore give a brief summary on how to use it,
and what functionality is available to the application programmer.

\subsubsection{Settings}
The application programmer has a couple of settings available. It is possible to
configure how history should be handled, i.e., which history file to use, and if
history should be automatically added to the history file. History in this
context is all non-empty lines that has been entered into the command-line of
the application. This enables the end-user of the application to search through
previously entered commands, or simply browse through them.

Another quite useful setting is the ability to set custom 'completion
functions', which allows the application programmer to decide in what manner the
tab completions should be handled. The interface for using these were in our
case a little cumbersome, and we have made some suggestions on how to improve
upon this with a compositional interface for completion functions.

\subsection{Preferences}
Haskeline also provides the application programmer with the ability to read
end-user preferences from a file, which by default is read from the file
$\mathtt{\sim}$\textit{/.haskeline}. This allows the end-user to configure the
application to his/her liking. For example:

\begin{verbatim}
  editMode: Vi
  completionType: MenuCompletion
  maxhistorysize: Just 40
\end{verbatim}

which changes how the interface behaves for the end-user.

\subsubsection{Interesting techniques}
Haskeline uses the Haskell Foreign Function Interface when interfacing with C in
order to be able to perform very low level operations on the system. For example
the System.Console.Haskeline.Directory module make use of FFI in order to define
some basic system file handling functionality which was not available in older
versions.

Another interesting technique used is the monad stack in InputT, where
haskeline make use of Readers with IORefs (which is basically a State) in order
to prevent state loss when encountering exceptions such as Ctrl-c.

\begin{verbatim}
-- | A monad transformer which carries all of the state and settings
-- relevant to a line-reading application.
newtype InputT m a = InputT {unInputT ::
            ReaderT RunTerm
            -- Use ReaderT (IO _) vs StateT so that exceptions (e.g., ctrl-c)
            -- don't cause us to lose the existing state.
            (ReaderT (IORef History)
            (ReaderT (IORef KillRing)
            (ReaderT Prefs
            (ReaderT (Settings m) m)))) a}
        deriving (Monad, MonadIO, MonadException)
\end{verbatim}

by having a stack of readers, some of which use IORefs (to simulate a state), the
monad might be more convenient to work with as they have made it possible to
use the ask function everywhere in monads of Reader instance.

The magic comes from defining clever instances for the monad transformers in
haskeline Monads.hs ask can be used to get any immutable variable in the reader
stack.

An alternative stack as we see it could be

\begin{verbatim}
newtype InputT m a = InputT {unInputT ::
                                ExceptT Err
                                (StateT Env
                                (ReaderT RunTerm
                                (ReaderT Prefs
                                (ReaderT (Settings m) m)))) a }
\end{verbatim}

Where it would also be possible to preserve the state after an exception is
thrown \footnote{\url{http://stackoverflow.com/questions/17645655/exception-handling-with-statet-vs-readert-ioref}}

\textbf{Explain why}

- Interface with C
- Reader stack? / Own StateT
- Implementation of error robust state


\subsection{Monite shell}
\label{monite}

Monite is a shell written in Haskell. During the Feldspar guest lecture we
learned that many hackage packages are named after various types of rock
formations. Following this convention the name Monite (an abbreviation) was
derived from the group name of extinct marine animals Ammonites, e.g., fossils
of various types of shells, which is what we are developing, a shell.

\subsubsection{Used libraries}

Monite shell is built using a couple
of libraries; the major three being: haskeline, BNFC, and process.

Haskeline is used used to provice a rich command-line interface for the
end-user. Monite is customizable to the end-users preferences in the
configuration file $\mathtt{\sim}$\textit{/.moniterc}. It also provides monite
with a history file, and useful completion functions. The end-user can
tab-complete commands entered at the command-line, and using our customized
completion function we look in the users \$PATH, in order to suggest completions
for the first word entered at the command-line, and then we use the standard
file completion from haskeline for tab-completion of the arguments.

BNFC is a parsing library, and is used in monite to parse a small scripting
language, which is available to the end-user to enter at the command line. We
have written our own BNFC grammars, and BNFC can then generate a lexer, and a
parser from these grammars, which are used to parse the commands entered on the
command-line in monite. The abstract syntax tree is then evaluated using our own
own evaluation functions.

The process library is used to allow for easy execution, and handling of binary
processes such as ls, cat, echo, etc, as well as to create pipes to allow
piping of commands, and redirection of stdout. We support redirection, e.g.,
"ls > filef", and "cat < filef" and piping, e.g., "ls | wc | wc | wc".

\subsubsection{Features}
\label{features}
Tab-completion, history file, configuration, redirection, piping, (small)
scripting language, script execution, interrupt handling (Ctrl-c).

The syntax of our scripting language is as follows:

\begin{verbatim}
  LetExp ::= let Lit = Wrap | let Lit = Wrap in LetExp | Exp
  Exp    ::= { LetExp : Lit <- Exp } | [ Cmd, Cmd ... ] | Wrap Wrap ...
  Wrap   ::= (( Wrap Wrap ... )) | Cmd
  Cmd    ::= Text Text ... | Cmd ``|'' Cmd | Cmd > Lit | Cmd > Lit
  Text   ::= String | Lit
\end{verbatim}

Where a literal is a sequence of characters not in the set:
\begin{verbatim}
  "\"\',()[]<>|{};:\t\n "
\end{verbatim}

\textbf{Let expressions}

Let expressions extend the current scope with a new variable of type Lit. If a
variable is called ``x'', it can be referenced by using ``\$x''.  When using the
let x = $\dots$ syntax, the variable is set globally, but when the let x =
$\dots$ in Exp syntax is used, the variable is only available within Exp, and
deleted afterwards. Example:

\begin{verbatim}
  let x = 42 ;
  let x = hello in echo $x ; # Should print "hello"
  echo $x ; # Should print "42"
\end{verbatim}

Only values can be assigned to variables. This is enforced by using the type
Wrap, which is either a command (which can be stored as string) or list of
Wraps within parentheses. These parentheses mean that whats inside it should be
evaluated before it is stored. Therefore, let x = ls will just store the string
``ls'', whereas let x = ((ls)) will store the output of running ls (As of now,
we don't handle the formatting of the command more than joining the string with
spaces, this could be improved in a more polished version). Example:

\begin{verbatim}
  let x = ls ;
  $x ; # Will execute ls
  let x = ((ls)) ;
  echo $x ; # Will print the output of ls using echo
\end{verbatim}

\textbf{List comprehensions}

The list comprehension evaluates the rightmost expression to a list of strings,
and for each string $s$ in this list, assigns it to the variable $i$ and
evaluates the leftmost expression with $i$ in its context.

\begin{verbatim}
  { echo $i : i <- ls } ; # echo each element from the list from ls
\end{verbatim}

\textbf{Lists}

Lists contain commands, and evaluating a list by itself only prints the
commands as they are. They can be used within list comprehensions to execute
the commands, for example:

\begin{verbatim}
  { $i : i <- [pwd, ls] } ; # Should print the output of first pwd, the ls
\end{verbatim}

\textbf{Commands and Wraps}

Commands are the things that are actually executed in the language. A command
is a list of Text, perhaps combined with pipes and redirects. Since texts can
contain variables, evaluating a command involves replacing all variables by
their value and redirecting the input/output according to pipes.

In order to make the language more useful, Wraps were introduce to let the user
capture the output of a command and use it as a value. As explained earlier,
anything within ``(())'' should be evaluated before it is used. Since it can
contain variables that must be replaced by their values, and these values may
contain pipes and redirects (see example below), it must be flattened to a
string and then reinterpreted. This way, the output of a command can be used
just like a value. To make it behave like a single value, explicit " are added
around the result when it is not the first part of a command, as it should be
the binary to be executed then.

\begin{verbatim}
  let x = ls -l | wc in echo $x (($x)) ; # Should print both
\end{verbatim}




The syntax works as follows: Everything that is entered is interpreted as
strings, unless it is wrapped in ``$\left( \left(  \right) \right)$'' (in which
case it is taken as an expression returning a string).

\begin{verbatim}
  let x = ls -l | wc in echo $x (($x))
\end{verbatim}

This will print first the text ``ls -l | wc'' and then the result of running
that command. (The formatting is not yet fully correct, but could be fixed with
some more time)

\subsubsection{Development}

The writing of this shell took longer than expected (which could be expected...)
. The shell comprises of three parts: The Grammar, the input handling, and the
interpreter/evaluator. The grammar is specified in the file Grammar.cf, which
with the help of bnfc generates a parser, Par.hs (along with a lexer, and an
abstract syntax

\textbf{Techniques and Reflection}

In writing our monite shell, we have used several of the development techniques
discussed in the course. Obviously, Monads have played a huge part in the
writing of our program, as we are in need of both State, IO and Error handling.
In order to get our MoniteM monad we used the concept of Monad transformers
which has been a big part of the course. Using transformers we get a lot of
things for free, for example getting and modifying the state, performing io
actions using liftIO and throwing and catching errors. One thing that was
tricky despite our transformer stack was to use it along with the InputT
transformer from haskeline. In order to catch the Ctrl-C interrupt, we had to
have a monad in the MonadException typeclass defined within haskeline. Even
though there were instances for some transformers, there was none for the
ExceptT that we use, only for the deprecated ErrorT. Luckily, it was enough to
run IO-actions within the things we wanted to catch, and IO was one of
predefined instances. Otherwise we would either have had to create our own
instance of MonadException which proved to be tricky, change our transformer
stack to the deprecated ErrorT which would have been a step back, or possibly
update the monad stack in haskeline with ExceptT instead of ErrorT.

Throughout the project, we noticed that it is hard to nail the grammar in the
first try, and that it may be good to start over. It took some time getting it
right, and there still may be room for improvements, perhaps using something
else than bnfc for the grammar. Reworking the grammar takes very long as the
entire interpreter must be changed to reflect it, and it can thus be worth
taking even more time getting it right in the first place.

\textbf{Missing features}

More general configuration file, the configuration supported now is that which
haskeline provides by default, it would be nice to be able to set a custom
prompt, and define custom functions. This could be done in many ways, and one
interesting way would be to expose a haskell config file to the end-user, in
which he/she could define their own functions (with the whole power of haskell
at their disposal), and then allow the end-user to run a command such as "monite
--recompile" which would recompile the whole shell with the user defined
functionality. This is used in applications such as xmonad, and provides the
end-user with a very rich, and powerful configuration interface. An example of a
library that claims to do this is 'dyre', which might be interesting to look
into.

Another way would be to extend the scripting language with support for
functions, which we realized was beyond the scope of this project. It would be
nice to be able to set environment variables in the scripting language, e.g.,
allow the end-user can set his/her own \$PATH.

Job control is another missing feature that monite could be extended with
(probably a necessity for it to be considered a usable shell).

There is also room for improvements on the completion functions used by Monite.
It would be possible to write completion functions for arguments to binary
commands which looks through the documentation of the command, and prints
suggestions for what arguments could be given to the command. For exmaple:

\begin{verbatim}
  $> git <Tab>
\end{verbatim}

could go through the git ducumentation and suggest all possible arguments that
could be entered.

\textbf{Known Issues}

After testing the shell throughout the development using ghci, we managed to
get the Ctrl-C - handling working as intended, where pressing Ctrl-C during
execution of an expression would result in a message being printed and the
whole expression aborted. Upon testing the compiled version prior to submission
though, we discovered that it does not behave this way when compiled. Instead,
only the current command is aborted, for example sleep 5 ; ls will print ls
even if Ctrl-C is pressed during the execution of sleep. As this issue was not
discovered until just before the hand in, there was no time to look into a fix.

Using wraps does not currently conserve the formatting of the run command (see the last example of let expressions in section \ref{features} for an example of this behaviour). Fixing this would

\subsection{Outcome}

Overall, we are pleased with the result of this project. We have managed to
create a (perhaps a bit limited) functioning shell, that can perform most basic
tasks, and have learned a lot in the process. We have also had the opportunity
to look at and change a part of the haskeline code base. We have stuck quite
closely to our original plan, even though the grammar and some concrete syntax
had to be changed (for example using ``$\{\}$'' and ``$|$'' in list comprehensions
to avoid confusion between ordinary lists and pipes for bnfc).

We realized quickly that having functions in our language would be way beyond
the scope of this project, but also that getting the few features we wanted
proved to be harder than we had initially thought.

% TODO: Move to own Testing-section
As was predicted, there was not much time left for testing. We had a small
testsuite running throughout, but had some problems with making it fully
automatic, as the redirection of its output seemed to give the strings in
different order. Also, making the tests fully general is hard, as the results
of the commands run depepends on the system environment. One idea however, is
to have the testsuite run another shell (for instance bash) and perhaps
generate random commands that are run by both shells, and then compare the
output. The challange would be to generate commands that behave nicely and dont
reformat your hard drive.














\newpage
\appendix

\section{Part I - (Same as last submission)}
For this assignment, we have chosen the package ‘haskeline’. Haskeline is used
to provide a more advanced means of getting input from the user than using the
standard ‘getLine’ function in Haskell. It provides functionality similar to
that of the GNU 'readline' library for C, used in many linux applications. We
think haskeline is an interesting package as it provides a very easy way of
getting a nice input interface for your haskell command line applications.

Our idea is to implement a simple shell in haskell using this library along with
the process library to pass on the calls to the system binaries. In order to
make it a bit more interesting, we thought it would be fun to add some basic
scripting functionality to the shell (as in bash/zsh). Since the project is so
short, this scripting language would have to be very limited. The things we have
planned are:

Variables using let expressions, for example:
\begin{verbatim}
  let $x = ls -la in x | wc; cd ..; x
\end{verbatim}

Which would be equivalent to:

\begin{verbatim}
  ls -la | wc; cd ..; ls -la
\end{verbatim}

Not only should it be possible to have variables in scope for the coming
command, but also for the whole session:

\begin{verbatim}
  let $x = hello; echo $x
\end{verbatim}

List comprehensions over lists of output values from another command:

\begin{verbatim}
  [ echo $x | $x <- ls ]
\end{verbatim}

Which would correspond to (in zsh):

\begin{verbatim}
  for $f in $(ls); do echo $f; done
\end{verbatim}

Functions (this is by far the hardest part, and may not be feasible for such a small project):

\begin{verbatim}
  let f n = n + 1 in echo (f 0)
\end{verbatim}

Which would be interpreted / evaluated as:

\begin{verbatim}
  echo 1
\end{verbatim}

In order to write such a shell application, we would need to write a parser for
the user input. Luckily, the package 'bnfc' makes it easy to generate a parser
automatically from a specified grammar, and by having a very restricted set of
features it should not be too hard to write those rules.

With a finished parser, the challenge will be to put it all together, i.e.,
handling user input via haskeline, parsing (and interpreting) the scripting
language via the bnfc generated parser, and handling system binary execution via
the process library. Our haskell shell will also need to handle the state of the
shell, that is, the current path and variables. One possible extension would be
to implement even more advanced shell functionality such as job control (way out
of scope for this project, but it would be cool to have).


We believe this project would cover the course goals in the following ways:

\textbf{DSLs}: Both bnfc and haskeline are DSLs, so working with them will require
understanding how they work. Our own scripting language will be a DSL in itself,
and by implementing it, we will need to handle both the concrete and abstract
syntax of our language, as well as the semantics when evaluating it.

\textbf{Types}: Writing the code for this project will inevitably include writing our own
types, and since our shell will no doubt have to be at least in the IO monad
(and the State monad), we will use monad transformers to construct it. Also, the
abstract syntax will be an algebraic datatype.  The haskeline library uses quite
a big stack of monad transformers (mostly ReaderT). If functions are to be
implemented in our shell language, we might need to use a GADT to model the
expressions.

\textbf{Spec / Testing}: Ideally, we would also like to create  a proper testsuite
(preferably using quickCheck) for our program, but as time will be very limited,
this will only be done if there is time left. Since the program will be mostly
monadic, proving properties might be hard.

We realise that this might be an ambitious undertaking, and we have consulted
one of the TAs about the project. The recommendation was to focus on the
haskeline library, and instead question it’s implementation choices, and try to
make suggestions on how to improve upon them. However, we feel that writing a
simple shell could be a really interesting project, and we would like to give it
a try, but, should we realise early that this is not feasible within the limited
time-frame of this course, we will instead go with the TAs recommendation and
focus on the haskeline library itself.



\end{document}
